# Пояснения по лабораторной работе №11

Эта работа продолжает работу с циклическими алгоритмами и учит считать сумму S заданного ряда.

> [!CAUTION]
> Эта работа вызвала много вопросов у нынешних студентов, поэтому необходимо пояснить следующее.
>
> Нужно понимать: суммируемый ряд де-факто является максимально приближённым значением к данной в задании функции.
> Таким образом, значение ряда из задания x/1+x^3/2+x^5/3+...+x^(2k-1)/k+... очень приближён к значению функции (-1/x)*ln(1-x^2).
> Ошибка, которую мы вычисляем в коде – это разница между значением функции и значением ряда. %lg – спецификатор для вывода очень малых чисел в удобной форме (например, 1e-5).
> 
> Кроме того, для конкретной задачи шаг 0.1 оказался слишком большим и неточным, поэтому шаг уменьшен до 0.01.

Разберём код решения данной задачи. Перечитывайте по несколько раз, если что-то кажется сложным!

```c
#include <stdio.h> // Подключение основной библиотеки в языке для ввода/вывода
#include <math.h> // Подключение модуля для работы с математическими функциями
#include <windows.h> // Подключение модуля windows.h для установки кодировки вывода

int main() { // Объявляем основную функцию
    SetConsoleOutputCP(CP_UTF8); // Устанавливаем кодировку UTF-8 для вывода в консоли русских символов

    double eps, X, u, s, trueValue, error; // Объявляем переменные для хранения значений погрешности, аргумента, члена ряда, суммы ряда, истинного значения и ошибки

    printf("Введите погрешность eps: "); // Выводим запрос на ввод погрешности eps
    scanf("%lf", &eps); // Читаем значение eps и сохраняем его в переменную

    printf("X\tСумма ряда\tИстинное значение\tОшибка\n"); // Выводим шапку таблицы результатов

    for (X = 0.50; X < 0.80; X += 0.05) { // Цикл для обхода значений X от 0.50 до 0.80 с шагом 0.05
        s = 0; // Инициализация суммы ряда
        int n = 1; // Объявление и инициализация счетчика для ряда

        do {
            u = pow(X, 2 * n - 1) / n; // Вычисление члена ряда
            s += u; // Добавление члена ряда к сумме
            n++; // Увеличение счетчика ряда
        } while (fabs(u) > eps); // Продолжаем, пока абсолютное значение очередного члена ряда больше погрешности

        trueValue = -(1 / X) * log(1 - pow(X, 2)); // Вычисление истинного значения функции
        error = trueValue - s; // Вычисление ошибки между истинным значением и суммой ряда
        printf("%.2lf\t%.6lf\t%.6lf\t%.6lg\n", X, s, trueValue, error); // Выводим значения X, суммы ряда, истинного значения и ошибки
    }

    return 0; // Завершаем программу с возвращением 0
}
```

> [!IMPORTANT]
> Если Вы используете не Windows, а, например, macOS, то проблем с кодировкой быть не должно — в таком случае игнорируйте следующие строки:
> ```c
> ...
> #include <windows.h> // Подключение модуля windows.h для установки кодировки вывода
> ...
>      SetConsoleOutputCP(CP_UTF8); // Устанавливаем кодировку UTF-8 для вывода в консоли русских символов: иначе будут иероглифы
> ```
>
> В операционных системах семейства Linux могут быть свои заморочки с кодировкой. Если что-то работает не так, как ожидается, то заглядывайте в Google :)

Сложность задачи – исключительно в понимании условия и знании цикла do-while.

> [!TIP]
> По всем вопросам можно [обращаться ко мне в Telegram](https://t.me/plunkzy)